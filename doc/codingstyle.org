* FMRT SoC 代码规范


Verilog HDL 程序一个代码文件中仅包含一个模块，并且文件名与模块名一致。

代码中避免使用魔术数字（Magic number），应采用宏。魔术数字是指嵌入代码中的常数。不使用魔术数字可以增强代码的可移植性。全部宏都在头文件中定义。

每行代码文字数量都在 80 以内，行的缩进使用制表符。制表符的优点是宽度可在文本编辑器内设定，阅读代码的人可以自由调整。

** 变量名与宏的命名规则

*变量名* 应包含以下三类信息：
- 变量的内容（它代表什么）
- 数据的种类（具名常量、简单变量、用户自定义类型）
- 变量的作用域（局部或者全局的作用域）

*变量名* 使用英文小写字母、数字以及下划线（_）进行命名。

为了明确控制信号的极性， *负逻辑信号线* 的名称以下划线（_）结尾。

*宏* 使用英文大写字母、英文小写字母、数字以及下划线（_）进行命名。

*常数* 使用大写英文字母和下划线（_）进行命名。

在定义 *比特位* 或 *总线* 时，使用单词首字母大写的驼峰拼写法（Upper CamelCase）。

宏的定义在头文件中进行。头文件中加入包含文件防范（Include guard）语句防止重复定义。包含文件防范是防止同一个文件被多次包含的技术。包含文件中的代码全部写在 ~`ifndef~ 之中，并在其中定义防范用的宏。当再次引用该文件时， ~`ifndef~ 中的代码就会无效。命名规则如下：

#+BEGIN_SRC 

`ifndef _ _INC_GUARD_ _      // 包含文件防范
    `define _ _INC_GUARD_ _  // 包含文件防范用的宏

    `define DataBus 31:0     // 比特位或总线用驼峰拼写法
    `define DATA_W  32       // 常数使用大写英文字母和下划线
`endif                       // 包含文件防范

#+END_SRC

** 选择好变量名的注意事项

*** 最重要的命名注意事项

为变量命名时最重要的考虑事项是，该名字要完全、准确地描述出该变量所代表的事物。获得好名字的一种实用技巧就是用文字表达变量所代表的是什么。通常，对变量的描述就是最佳的变量名。

- 更多变量名的例子
| 变量的用途 | 好名字，好描述         | 坏名字，差描述       |
| 当前日期   | currentDate, todaysDae | cd, current, date, c |
| 每页的行数 | linesPerPage           | lpp, lines, l, x     |

*** 以问题为导向

一个好记的名字反映的通常都是问题，而不是解决方案。一个好名字通常表达的是 “什么”（what），而不是 “如何”（how）。

一条员工数据记录可称作 ~inputRec~ 或 ~employeeData~ 。~inputRec~ 是一个反映输入、记录这些计算概念的计算机术语，  ~employeeData~ 则直指问题领域，与计算的世界无关。

*** 最适当的名字长度

足够长，可以让你无须苦苦思索，同时避免名字太长了 —— 长得很不实用。

Gorla 和 Benander 发现，当变量名的平均长度在 10 到 16 个字符的时候，调试程序所需花费的气力是最小的（1990）。平均名字长度在 8 到 20 个字符的程序也几乎同样容易调试。这项原则并不意味着你应该尽量吧变量名控制在 9 到 15 或者 10 到 16 个字符长。它强调的是，如果你查看自己写的代码时发现了很多更短的名字，那么 需要认真检查，确保这些名字含义足够清晰。

- 变量名太长、太短或刚好合适的实例
| 太长   | numberOfPeopleOnTheUsOlympicTeam   |
| 太短　 | n, np, ntm                         |
| 正好   | numberTeamMemoers, teamMemberCount |

*** 变量名中的计算值限定词

很多程序都有表示计算结果的变量：总额、平均值、最大值等等。如果你要用类似于 Total、Sum、Average、Max、Min、Record、String、Pointer 这样的限定词来修改某个名字，那么请记住 *把限定词加到名字的最后* 。

首先，变量名中最重要的那部分，即为这一变量赋予主要含义的部分应当位于最前面，显得最为突出，并会被优先阅读到。其次，将避免由于同时在程序中使用 totalRevenue 和 revenueTotal 而产生的歧义。这些名字在语义上是等价的，上述规则可以避免将它们当作不同的东西使用。还有，类似 revenueTotal（总收入）、expenseTotal（总支出）、revenueAverage（平均收入）、expenseAverage（平均支出）这组名字的变量具有非常优雅的对称性。而从 totalRevenue、expenseTotal、revenueAverage、averageExpense 这组名字中则看不出什么规律来。总之，一致性可以提高可读性，简化维护工作。 

把计算的量放在名字最后的这条规则也有例外，那就是 Num 限定词的位置已经是约定俗成的。Num 放在变量名的开始位置代表一个总数：numCustomers 表示的是员工的总数。Num 放在变量名的结束位置代表一个下标：customerNum 表示的是当前员工的序号。通过 numCustomers 最后代表复数的 s 也能够看出这两种应用之间的区别。然而，由于这样使用 Num 常常会带来麻烦，因此可能最好的办法是避开这些问题， *用 Count 或者 Total 来代表员工总数，用 Index 来指代某个特定的员工* 。这样，customerCount 就代表员工的总数，customerIndex 代表某个特定的员工。

*** 变量名对作用域的影响

短的变量名总是不好吗？不，不总是这样。当你把一个变量名取得很短的时候，如 i,这一长度本身就对该变量做出了一些说明 —— 也就是说，该变量代表的是一个临时的数据，它的作用域非常有限。

阅读该变量的程序员应该会明白，这一数值只会用于几行代码之内。当你把变量命名为 i 的时候，你就是在表示“这是一个普通的循环计数器或者数组下标，在这几行代码之外他没任何作用”。W.J.Hansen 所做的一项研究表明，较长的名字适用于很少用到的变量或者全局变量，而较短的名字则适用于局部变量或者循环变量（Shneiderman 1980）。不过，短的变量名常常会带来一些麻烦，因此，作为一项防御式编程策略，一些细心的程序员会避免使用短的变量名。

*对位于全局命名空间中的名字加以限定词* 如果你在全局命名空间中定义了一些变量（具体常量、类名等），那么请考虑你是否需要采用这种方式对全局命名空间进行划分，并避免产生命名冲突。为全局可见的类加上带有子系统特征的前缀。用户接口部分的雇员类可能命名为 uiEmployee，数据库部分的雇员类可能命名为 dbEmployee，这样做能把全局命名空间的命名冲突降到最低。

*** 变量名中的常用对仗词

对仗词的使用要准确。通过应用命名规则来提高对仗词使用的一致性，从而提高其可读性。比如像 begin/end 这样的一组用词非常容易理解和记忆。而那些与常用语言相去甚远的词则通常很难记忆，有时甚至会产生歧义。下面是一些常用的对仗词：

- begin/end
- first/last
- locked/unlocked
- min/max
- next/previous
- new/old
- opened/closed
- visible/invisible
- source/target
- source/destination
- up/down

** 为特定类型的数据命名 

*** 为循环下标命名

i、j 和 k 这些名字都是约定俗成的：

- 简单的循环变量名
#+BEGIN_SRC java

for ( i = firstItem; i < lastItem; i++ ) {
    data[ i ] = 0;
}

#+END_SRC

如果一个变量要在循环之外使用，那么久应该为它取一个比 i、j 或者 k 更有意义的名字。举个例子，如果你在从文件中读取记录，并且需要记下所读记录是数量，那么类似于 recordCount 这样的名字就很适合：

- 描述性较好的循环变量名
#+BEGIN_SRC java

recordCount = 0;
while ( moreSource() ) {
    score[ recordCount ] = GetNextScore();
    recordCount++;
}

// lines using recordCount
...

#+END_SRC

如果循环不止几行，那么读者会很容易忘记 i 变量具有的含义，因此最好给循环下标换一个更有意义的名字。由于代码会经常修改、扩充，或者复制到其他程序中去，因此，很多有经验的程序员索性不使用类似于 i 这样的名字。 

导致循环变长的常见原因之一是出现循环的嵌套使用。如果你使用多个嵌套的循环，那么就应该给循环变量赋予更长的名字以提高可读性：

- 嵌套循环中的号循环变量名
#+BEGIN_SRC java

for ( teamIndex = 0; teamIndex < teamCount; teamIndex++) {
     for ( eventIndex = 0; eventIndex < eventCount[ teamIndex ]; eventIndex++ ) {
          score[ teamIndex ][ eventIndex ] = 0;
     }
}

#+END_SRC

谨慎地为循环下标变量命名可以避免弄串下标的常见问题：想用 j 的时候写了 i，想用 i 的时候却写了 j。同时，这也使得数据访问变得更加清晰：score[teamIndex][eventIndex] 要比 score[i][j] 给出的信息更多。 

如果一定要用 i、j 和 k，那么不要把它们用于除了简单循环的循环下标之外的任何场合 —— 这种传统已经太深入人心了，一旦违背该原则，将这些变量用于其他用途就可能造成误解。要想避免出现这样的问题，最简单的方法就是想出一个比 i、j 和 k 更具描述性的名字来。

***  为状态变量命名

状态变量用于描述你的程序的状态。

*为状态变量取一个比 flag 更好的名字。* 最好是把标记（flag）看做状态变量。标记的名字中不应该含有 flag，因为你从中丝毫看不出该标记是做什么的。为了清楚起见，标记应该用枚举类型、具名常量，或用作具名常量的全局变量来对其赋值，而且其值应该与上面这些量作比较。下面例子中标记的命名都很差：

- 含义模糊的标记
#+BEGIN_SRC c++

if ( flag )  ...
if ( statusFlag & 0X0F )  ...
if ( printFlag == 16 )  ...
if ( computeFlag == 0 )   ...

flag        = 0x1;
statusFlag  = 0x80;
printFlag   = 16;
computeFlag = 0;

#+END_SRC

像 statusFlag = 0x80 这样的语句是反映不出这段代码能做上面的，除非你亲自写了这段代码，或者有文档能告诉你 statusFlag 和 0x80 的含义。下面是作用相同但更为清晰的代码：

- 更好地使用状态变量
#+BEGIN_SRC c++

if ( dateReady )  ...
if ( characterType & PRINTABLE_CHAR )  ...
if ( reportType == ReportType_Annual )  ...
if ( RecalcNeeded == false )   ...

dateReady     = true;
characterType = CONTROL_CHARCTER;
reportType    = ReportType_Annual;
RecalcNeeded  = false;

#+END_SRC

可以结合枚举类型和预定义的具名常量来使用这种方法：

- 声明状态变量（C++）
#+BEGIN_SRC c++

// values for CharacterType
const int                   = 0x01;
const int                   = 0x02;
const int                   = 0x04;
const int LINE_DRAW         = 0x08;
const int PRINTABLE_CHAR    = （LETTER | DIGIT | PUNCTYATION | LINE_DRAW）;
const int CONTROL_CHARACTER = 0x80;

// values for ReportType
enum ReportType{
    ReportType_Daily,
    ReportType_Monthly,
    ReportType_Quarterly,
    ReportType_Annual,
    ReportType_All
};

#+END_SRC

如果你放心自己需要猜测某段代码的含义的时候，就该考虑为变量重新命名。猜测谋杀案中谁是神秘凶手是可行的，但你没有必要去猜测代码，你应该能直接读懂它们。

*** 为临时变量命名

临时变量用于存储计算的中间结果，作为临时占位符，以及存储内存管理值。它们常被赋予 temp、x 或者其他一些模糊且缺乏描述性的名字。通常，临时变量是一个信号，表明程序员还没有完全把问题弄清楚。而且，由于这些变量被正式地赋予了一种“临时”状态，因此程序员会倾向于其他变量更为随意地对待这些变量，从而增加了出错的可能。 

警惕“临时”变量。 临时性地保存一些值常常是很有必要的。但是无论从哪种角度看你程序中的大多数变量都是临时的。把其中几个称为临时的，可能表明你还没有弄清它们的实际用途。请考虑下面的示例：

- 不提供信息的“临时”变量名
#+BEGIN_SRC c++

// Compute roots of a quadratic equation.
// This assumes that ( b^2 - 4*a*c ) is positive.
temp    = sqrt( b^2 - 4*a*c );
root[0] = ( -b + temp ) / ( 2 * a );
root[1] = ( -b - temp ) / ( 2 * a );

#+END_SRC

把表达式 sqrt( b^2 - 4ac ) 的结果存储在一个变量里是很不错的，特别是当这一结果还会被随后两次用到的时候。但是名字 temp 却丝毫也没有反映该变量的功能。下面例子显示了一种更好的做法：

- 用真正的变量替代 “临时” 变量名
#+BEGIN_SRC c++

// Compute roots of a quadratic equation.
// This assumes that ( b^2 - 4*a*c ) is positive.
discriminant = sqrt( b^2 - 4*a*c );              // 判别式 discriminant
root[0]      = ( -b + discriminant ) / ( 2*a );
root[1]      = ( -b - discriminant ) / ( 2*a );

#+END_SRC

就本质而言，这段代码与上面一段是完全相同的，但是它却通过使用了准确而且具有描述性的变量名（discriminant，判别式）而得到了改善。

*** 为布尔变量命名

*谨记典型的布尔变量名* 下面是一些格外有用的布尔变量名。

- *done* 表示某件事情已经完成。可用于表示循环结束或者一些其他的操作已完成。在事情完成之前把 ~done~ 设为 ~false~ ，完成之后设为 ~true~ 。

- *error* 表示有错误发生。在错误发生之前设为 ~false~ ，已经发生时设为 ~true~ 。

- *found* 表明某个值已经找到了。在没找到该值之前设为 ~flase~ ，一旦找到就设为 ~true~ 。

- *success* 或 *ok* 表明一项操作是否成功。操作失败时设为 ~false~ ，操作成功时设为 ~true~ ，如果可以，请用一个更具体的名字代替 success，以便更具体地描述成功的含义。如果完成处理就表示这个程序执行成功，那么或许应该用 processingComplete。如果找到某个值就是程序执行成功，那么应该换用 found。

*赋予布尔变量隐含“真假”含义的名字*  像 ~done~ 和 ~success~ 这样的名字是很不错的布尔变量名，因为其状态要么是 ~true~ ，要么是 ~false~ ；某件事完成了或者没有完成；成功或者失败。另一方面，像 ~status~ 和 ~sourceFile~ 这样的名字却是很糟的布尔变量名，因为它们没有明确的 ~true~ 或者 ~false~ 。 ~status~ 是 ~true~ 反映的是什么含义？它表明某件事情拥有一个状态吗？每件事都有状态。 

为了取得更好的效果，应该把 ~status~ 替换为类似于 ~error~ 或者 ~statusOK~ 这样的名字，同时把 ~sourceFile~ 替换为 ~sourceFileAvailable~ 、 ~sourceFileFound~ ，或者其他能体现该变量所代表含义的名字。 

在布尔变量名前加上 Is, 这样变量就变成了一个问题： ~isdone~ ? 用 ~true~ 或 ~false~ 回答问题也就为该变量取值。优点之一是它不能用与那些模糊不清的名字： ~isStatus~ ? 这毫无意义。缺点之一是降低了简单逻辑表达式的可读性：　~if ( isFound ) 的可读性要略差于 ~if ( found )~ 。

*使用肯定的布尔变量名* 否定的名字如 ~notFound~ 、~notdone~ 以及 ~notSuccessful~ 等较难阅读，特别是如果它们被求反： 

~It not noFound~ 

这样的名字应该替换为 ~found~ 、 ~done~ 或者 ~processingComplete~ ，然后再用适当的运算符求反。如果你找到了想找的结果，那么久可以用 ~found~ 而不必写双重否定的 ~not notFound~ 了。

*** 为枚举类型命名

在使用枚举类型的时候，可以通过使用组前缀，如 Color_，Planet_ 或者 Month_ 来表明该类型的成员都同属于一个组。

- 为枚举类型采用前缀命名约定
#+BEGIN_SRC c++

enum Color {
       Color_Red,
       Color_Green,
       Color_Blue
};

enum Planet {
       Planet_Earth,
       Planet_Mars,
       Planet_Venus
};

enum Month {
       Month_January,
       Month_February,
       ...
       Month_December
}

#+END_SRC

*** 为常量命名

在具名常量时，应该根据该常量所表示的含义，而不是该常量所具有的数值为该抽象事物命名。 ~FIVE~ 是个很糟的常量名（不论它所代表的值是否为 ~5.0~ ）。 ~CYCLES_NEEDED~ 是一个不错的名字。 ~CYCLES_NEEDED~ 可以等于 ~5.0~ 或者 ~6.0~ 。而 ~FIVE = 6.0~ 就显得太可笑了。出于同样原因， ~BAKERS_DOZEN~ 就是个很糟的常量名，而 ~DONUTS_MAX~ 则不错。

** 创建具备可读性的短名字

熟悉多种缩写技巧会很有用，因为没有哪种方法能够适用于所有的情况。

*** 缩写的一般知道原则

下面是几项用于创建缩写的指导原则。其中的一些原则彼此冲突，所以不要试图同时应用所有原则。


- 使用标准的缩写（列在字典中的那些常见缩写）。
- 去掉所有非前置元音。（computer 变 cmptr，screen 变成 scrn，apple 变成 appl，integer 变成 intgr）
- 去掉虚词 and，or，the 等。
- 使用每个单词的第一个或前几个字母。
- 统一地在每个单词的第一、第二或者第三个（选择最合适的一个）字母后截断。
- 保留每个单词的第一和最后一个字母。
- 使用名字中的每一个重要单词，最多不超过三个。
- 去除无用的后缀 —— ing，ed 等。
- 确保不要改变变量的含义。
- 反复使用上述技术，直到你把每个变量名的长度缩减到了 8 到 20 个字符，或者达到你所用的编程语言对变量名的限制字符数。

*** 有关缩写的评论

在创建缩写的时候，会有很多的陷阱在等着你。下面是一些能够避免犯错的规则。

*不要用从每个单词中删除一个字符的方式来缩写*  键入一个字符算不上是什么额外工作，而节省一个字符带来的便利却很难抵消由此而造成的可读性损失。这就像日历中的 *“Jun”* 和 *“Jul”* 。你只有在非常着急的情况才有必要把 June 拼成 *“Jun”* 。对于大多数删除一个字母的做法而言，你很难回忆起自己是不是删了一个字符。所以要么删除不止一个字符，要么就把单词拼写完整。

*缩写要一致*  应该一直使用相同的缩写。例如，要么全用 ~Num~ ，要么全用 ~No~ （注：这里指的是 No.1 的 No 而不是 Yes or No 的 No），不要两个都用。与之类似，不要在一些名字里缩写某个单词而在其他名字里不缩写。比如，不要在有些地方使用完整的单词 ~Number~ ，同时在其他地方使用 ~Num~ 缩写。
    
*创建你能读出来的名字*  用 ~xPos~ 而不用 ~xPstn~ ，用 ~needsCompu~ 而不用 ~ndsCmptg~ 。此处可以借助电话来测试 —— 如果你无法在电话中向他人读出你的代码，就请重新给变量起一个更清晰的名字吧。
    
*避免使用容易看错或者读错的字符组合*  为了表示 B 的结尾， ~ENDB~ 要比 ~BEND~ 更好。如果你使用了一种好的分隔技术，那么就不需要这一条原则，因为 ~B_END~ 、 ~BEnd~ 或者 ~b_end~ 都不会被读错。

*使用辞典来解决命名冲突*  创建简短名字会带来的一项麻烦就是命名冲突 —— 缩写后名字相同。例如，如果命名长度被限制为 3 个字符，并且你需要在程序中的同一代码段使用 ~fired~ 和 ~full revenue disbursal~ ，你可能会不经意地把缩写都写出了 ~frd~ 。 避免命名冲突的一种简单做法是使用含义相同的不同单词，这样一来，有一部辞典就显得很方便。在本例中，可以用 ~dismissed~ 来代替 ~fired~ ，以及用 ~complete revenue disbursal~ 来代替 ~full revenue disbursal~ 。这样，3 个字母的缩写就分别变成了 ~dsm~ 和 ~crd~ ，从而消除了命名冲突。

*在代码里用缩写对照表解释极短的名字的含义*  当编程语言只允许用非常短的名字的时候，增加一张缩写对照表来为用户提升更多的变量含义。把该表格作为注释加到一段代码的开始。下面是一个例子：

- 良好的名字对照表
#+BEGIN_SRC verilog

/********************

Tranalation Table
Variable    Meaning
--------    -------
XPOS        x-Coordinate Position(in meters)
YPOS        y-Coordinate Position(in meters)
NDSCMP      Needs Computing (= 0 if no computation is needed;
                             = 1 if  computation is needed)
PTGTTL      Point Grand Total
PTVLMX      Point Value Maxinum
PSCRMX      Possible Score Maxinum

********************/

#+END_SRC

*在一份项目级的“标准缩写”文档中说明所有的缩写* 代码中的缩写会带来的两种常见风险。

- 代码的读者可能不理解这些缩写。
- 其他程序员可能会用多个缩写来代表相同的词，从而产生不必要的混乱。

创建一份“标准缩写”文档来记录项目中用到的全部编码的缩写。这份文档既可以是文字处理程序的文档，也可以是电子表格文档。在很大的项目里，它还可以是一个数据库。这份文档应签入（check in）到版本控制系统里，当任何人于任意时间在代码里创建一种新的缩写把它签出（check out）来修改。文档中的词条应该按照完整单词排序，而不是按照缩写排序。

这看上去可能显得非常麻烦，但是除了开始的一点额外工作，它事实上是建立了一种在项目中有效地使用缩写的机制。通过对所有用到的缩写加以说明，就解决了上面描述的两种常见风险中的第一种。程序员如果不费力把标准缩写文档从版本控制系统中 check out、输入新的缩写并把它 check in 回去，就不能常见一个新的缩写。这是件好事。它表明，只有当一个缩写在代码中应用非常广泛，程序员不惜花上很多精力来为它编写缩写文档，这一缩写才的的确确应当被创建。

这种方法通过降低程序员创建多余的缩写的缩写的可能性，从而解决了第二种风险。想创建缩写的程序员会把缩写文档 check out 并输入新的缩写。如果他想缩写的单词已经有了缩写，该程序员就会注意到它，并且去使用该现有的缩写而不创建一个新的。

本原则中体现出来的核心问题，是方便编写代码同方便阅读两种理念之间的差异。上面的方法很明显会带来代码编写时的麻烦，但是程序员们在整个项目生命周期里会把更多的时间花在阅读代码而不是编写代码之上。这种方法提高了阅读代码的方便性。当一个项目尘埃落定之后，它可能还会提高编写代码的方便性。

记住，名字对于代码读者的意义要比对作者更重要 去读一读你自己写的并且至少六个月诶看过的代码，注意哪些名字是你需要花功夫才能理解其含义的。应下决心改变导致这种混乱的做法。

** 应该避免的名字

- 避免使用令人误解的名字或者缩写
- 避免使用具有相似含义的名字
- 避免使用具有不同含义但却有相似名字的变量
- 避免使用发音相近的名字，比如 wrap 和 rap
- 避免在名字中使用数字
- 避免使用英语中常常拼错的单词
- 不要仅依靠大小写区分变量名
- 避免使用多种自然语言
- 避免使用标准类型、变量和子程序的名字
- 不要使用与变量含义完全无关的名字 
- 避免在名字中包含容易混淆的字符


** 总结

- 好的变量名是提高程序可读性的一项关键要素。对特殊种类的变量，比如循环下标和状态变量，需要加以特殊的考虑。 
- 名字要尽可能地具体。那些太模糊或者太通用以致于能够用于多种目的的名字通常都是很不好的。
- 命名规则应该能够区分局部数据、类数据和全局数据。它们还应该可以区分类型名、具名常量、枚举类型名字和变量名。
- 无论做哪种类型项目，你都应该采用某种变量命名规则。你所采用的规则的种类取决于你的程序的规模，以及项目成员人数。
- 代码阅读的次数远远多于编写的次数。确保你所取的名字更侧重于阅读方便而不是编写方便。
